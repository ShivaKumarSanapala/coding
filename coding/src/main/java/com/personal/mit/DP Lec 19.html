<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:S,mm:Q}=window,$=new S.Toolbar;$.attach(Q);const I=$.render();I.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(I)})})()</script><script>((l,U,M,R)=>{const N=l();window.mm=N.Markmap.create("svg#mindmap",(U||N.deriveOptions)(R),M),window.matchMedia("(prefers-color-scheme: dark)").matches&&document.documentElement.classList.add("markmap-dark")})(()=>window.markmap,null,{"content":"Dynamic Programming (DP): Fibonacci &amp; Shortest Paths","children":[{"content":"<strong>Introduction</strong>","children":[{"content":"<strong>Dynamic Programming (DP)</strong> is a key <strong>algorithm design technique</strong> for solving <strong>optimization problems</strong> (minimize/maximize objectives, e.g., shortest path).","children":[],"payload":{"tag":"li","lines":"3,4"}},{"content":"Think of DP as <strong>careful brute force</strong>, reducing exponential search to polynomial time by <strong>reusing subproblem solutions</strong>.","children":[],"payload":{"tag":"li","lines":"4,5"}},{"content":"Many polynomial-time solutions exist only via DP.","children":[],"payload":{"tag":"li","lines":"5,7"}}],"payload":{"tag":"h2","lines":"2,3"}},{"content":"<strong>Why &quot;Dynamic Programming&quot;?</strong>","children":[{"content":"Coined by <strong>Richard Bellman</strong> to sound respectable and avoid political controversy over mathematical research.","children":[],"payload":{"tag":"li","lines":"8,9"}},{"content":"&quot;Programming&quot; in the British sense meant <strong>optimization/planning</strong>.","children":[],"payload":{"tag":"li","lines":"9,11"}}],"payload":{"tag":"h2","lines":"7,8"}},{"content":"<strong>Core Idea of Dynamic Programming</strong>","children":[{"content":"<strong>Split a problem</strong> into <strong>subproblems</strong>.","children":[],"payload":{"tag":"li","lines":"12,13"}},{"content":"<strong>Solve</strong> (and store/remember) subproblem solutions.","children":[],"payload":{"tag":"li","lines":"13,14"}},{"content":"<strong>Reuse</strong> those solutions to avoid recomputation.","children":[],"payload":{"tag":"li","lines":"14,16"}}],"payload":{"tag":"h2","lines":"11,12"}},{"content":"<strong>Case Study: Fibonacci Numbers</strong>","children":[{"content":"<strong>Fibonacci Definition</strong>","children":[{"content":"<code>F(n) = F(n&#x2212;1) + F(n&#x2212;2)</code>","children":[],"payload":{"tag":"li","lines":"19,20"}},{"content":"Illustrates classic DP structure.","children":[],"payload":{"tag":"li","lines":"20,22"}}],"payload":{"tag":"h3","lines":"18,19"}},{"content":"<strong>Naive Recursive Computation</strong>","children":[{"content":"","children":[{"content":"\n<pre data-lines=\"25,32\"><code data-lines=\"25,32\">function fib(n)\n    <span class=\"hljs-keyword\">if</span> n &lt;= <span class=\"hljs-number\">1</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">else</span>:\n        <span class=\"hljs-keyword\">return</span> fib(n-<span class=\"hljs-number\">1</span>) + fib(n-<span class=\"hljs-number\">2</span>)\n</code></pre>","children":[],"payload":{"tag":"li","lines":"25,32"}},{"content":"<strong>Problem</strong>: This method is <strong>exponential time</strong>&#x2014;calculates the same subproblems repeatedly.","children":[],"payload":{"tag":"li","lines":"32,34"}}],"payload":{"tag":"ul","lines":"25,34"}},{"content":"","children":[{"content":"Recurrence for runtime: <code>T(n) = T(n&#x2212;1) + T(n&#x2212;2) + O(1)</code>","children":[],"payload":{"tag":"li","lines":"35,36"}},{"content":"Grows <strong>exponentially</strong> like the Fibonacci sequence: <code>&#x398;(&#x3c6;&#x207f;)</code> where <code>&#x3c6; &#x2248; 1.618</code>.","children":[],"payload":{"tag":"li","lines":"36,38"}}],"payload":{"tag":"ul","lines":"35,38"}}],"payload":{"tag":"h3","lines":"22,23"}},{"content":"<strong>Improving with Memoization</strong>","children":[{"content":"<strong>Memoization</strong> = <strong>store</strong> subproblem results for reuse.","children":[{"content":"Only <strong>calculate each subproblem once</strong>.","children":[],"payload":{"tag":"li","lines":"41,42"}},{"content":"<strong>Pseudocode:</strong><pre data-lines=\"44,53\"><code data-lines=\"44,53\">function fib_memo(n, memo)\n    <span class=\"hljs-keyword\">if</span> n &lt;= <span class=\"hljs-number\">1</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">if</span> n <span class=\"hljs-keyword\">in</span> memo:\n        <span class=\"hljs-keyword\">return</span> memo[n]\n    memo[n] = fib_memo(n-<span class=\"hljs-number\">1</span>, memo) + fib_memo(n-<span class=\"hljs-number\">2</span>, memo)\n    <span class=\"hljs-keyword\">return</span> memo[n]\n</code></pre>","children":[],"payload":{"tag":"li","lines":"42,53"}},{"content":"Each F(i)  is computed at most once:<br>\n<strong>Time complexity: O(n)</strong>","children":[],"payload":{"tag":"li","lines":"53,56"}}],"payload":{"tag":"h4","lines":"40,41"}},{"content":"<strong>General Memoization Framework</strong>","children":[{"content":"1. <strong>Identify Subproblems</strong>","children":[],"payload":{"tag":"li","lines":"57,58","listIndex":1}},{"content":"2. <strong>Store results</strong> (e.g., in a dictionary/table).","children":[],"payload":{"tag":"li","lines":"58,59","listIndex":2}},{"content":"3. <strong>Check</strong> for stored result <strong>before</strong> recomputation.","children":[],"payload":{"tag":"li","lines":"59,60","listIndex":3}},{"content":"4. <strong>Store new result</strong> after computation.","children":[],"payload":{"tag":"li","lines":"60,62","listIndex":4}}],"payload":{"tag":"h4","lines":"56,57"}}],"payload":{"tag":"h3","lines":"38,39"}},{"content":"<strong>Bottom-Up (Iterative) DP (Tabulation)</strong>","children":[{"content":"Solve from <strong>smallest subproblems to largest</strong>, <strong>iteratively</strong>.","children":[],"payload":{"tag":"li","lines":"63,64"}},{"content":"<strong>Fibonacci Example:</strong><pre data-lines=\"66,76\"><code data-lines=\"66,76\"><span class=\"hljs-keyword\">function</span> fib_bottom_up(n)\n    if n <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n    prev <span class=\"hljs-operator\">=</span> prev2 <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">from</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">to</span> n:\n        <span class=\"hljs-keyword\">current</span> <span class=\"hljs-operator\">=</span> prev <span class=\"hljs-operator\">+</span> prev2\n        prev2 <span class=\"hljs-operator\">=</span> prev\n        prev <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">current</span>\n    <span class=\"hljs-keyword\">return</span> prev\n</code></pre>","children":[],"payload":{"tag":"li","lines":"64,76"}},{"content":"<strong>Space Optimisation:</strong> Only last two Fibonacci numbers needed (<strong>O(1) space</strong>).","children":[],"payload":{"tag":"li","lines":"76,77"}},{"content":"<strong>Time Complexity: O(n)</strong>","children":[],"payload":{"tag":"li","lines":"77,79"}}],"payload":{"tag":"h3","lines":"62,63"}},{"content":"<strong>Memoization (Top-Down) vs Bottom-Up</strong>","children":[{"content":"<strong>Memoization</strong>: Top-down, natural for recursive problems, easier to code for recursion.","children":[],"payload":{"tag":"li","lines":"80,81"}},{"content":"<strong>Bottom-Up</strong>: Iterative; often more <strong>space-efficient</strong>, avoids recursion overhead; may be harder to conceptualize in some cases.","children":[],"payload":{"tag":"li","lines":"81,83"}}],"payload":{"tag":"h3","lines":"79,80"}}],"payload":{"tag":"h2","lines":"16,17"}},{"content":"<strong>DP Analysis</strong>","children":[{"content":"<strong>General Time Complexity:</strong><pre data-lines=\"86,89\"><code data-lines=\"86,89\">Total <span class=\"hljs-keyword\">Running</span> <span class=\"hljs-type\">Time</span> <span class=\"hljs-operator\">=</span> (Number <span class=\"hljs-keyword\">of</span> Subproblems) &#xd7; (<span class=\"hljs-type\">Time</span> <span class=\"hljs-keyword\">per</span> Subproblem)\n</code></pre>","children":[],"payload":{"tag":"li","lines":"84,89"}},{"content":"For Fibonacci: <code>n</code> subproblems, <code>O(1)</code> per subproblem &#x21d2; <code>**O(n)**</code>","children":[],"payload":{"tag":"li","lines":"89,91"}}],"payload":{"tag":"h2","lines":"83,84"}},{"content":"<strong>Case Study: Shortest Paths</strong>","children":[{"content":"<strong>Problem</strong>","children":[{"content":"<strong>Find the shortest path</strong> from a source <code>s</code> to every other node <code>v</code> in a graph.","children":[],"payload":{"tag":"li","lines":"96,98"}}],"payload":{"tag":"h3","lines":"94,95"}},{"content":"<strong>Naive Recursive (with Memoization) for Single Source to Any Vertex</strong>","children":[{"content":"","children":[{"content":"\n<p data-lines=\"100,101\"><strong>Key Insight:</strong></p>","children":[{"content":"<strong>Guess the last edge</strong> into <code>v</code> (from some <code>u</code>), then recursively solve for the path from <code>s</code> to <code>u</code>.","children":[],"payload":{"tag":"li","lines":"102,104"}},{"content":"","children":[{"content":"<code>&#x3b4;(s, v) = min over u &#x2192; v [&#x3b4;(s, u) + w(u, v)]</code>","children":[],"payload":{"tag":"li","lines":"106,107"}},{"content":"<strong>Base case:</strong> <code>delta(s, s) = 0</code>","children":[],"payload":{"tag":"li","lines":"107,109"}}],"payload":{"tag":"ul","lines":"106,109"}}],"payload":{"tag":"li","lines":"100,109"}},{"content":"\n<p data-lines=\"109,110\"><strong>Pseudocode:</strong></p>","children":[{"content":"\n<pre data-lines=\"112,126\"><code data-lines=\"112,126\">function shortest_path(s, v, memo):\n    <span class=\"hljs-keyword\">if</span> (s, v) <span class=\"hljs-keyword\">in</span> memo:\n        <span class=\"hljs-keyword\">return</span> memo[(s, v)]\n    <span class=\"hljs-keyword\">if</span> s == v:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    min_path = INFINITY\n    <span class=\"hljs-keyword\">for</span> each u <span class=\"hljs-keyword\">in</span> incoming_edges(v):\n        candidate = shortest_path(s, u, memo) + weight(u, v)\n        <span class=\"hljs-keyword\">if</span> candidate &lt; min_path:\n            min_path = candidate\n    memo[(s, v)] = min_path\n    <span class=\"hljs-keyword\">return</span> min_path\n</code></pre>","children":[],"payload":{"tag":"li","lines":"111,127"}}],"payload":{"tag":"li","lines":"109,127"}}],"payload":{"tag":"ul","lines":"100,127"}},{"content":"\n<p data-lines=\"129,130\"><strong>Issues:</strong></p>","children":[{"content":"<strong>Works only for Directed Acyclic Graphs (DAGs).</strong>","children":[],"payload":{"tag":"li","lines":"131,132"}},{"content":"With <strong>cycles</strong>, can cause <strong>infinite recursion</strong> due to circular subproblem dependencies.","children":[],"payload":{"tag":"li","lines":"132,136"}}],"payload":{"tag":"li","lines":"129,136"}}],"payload":{"tag":"h3","lines":"98,99"}}],"payload":{"tag":"h2","lines":"92,93"}},{"content":"<strong>DP on DAGs and Graphs with Cycles</strong>","children":[{"content":"<strong>For DAGs (No Cycles):</strong>","children":[{"content":"<strong>Number of subproblems:</strong> One per vertex (<code>V</code>).","children":[],"payload":{"tag":"li","lines":"142,143"}},{"content":"<strong>Time per subproblem:</strong> Number of incoming edges (<code>indegree(v)</code>).","children":[],"payload":{"tag":"li","lines":"143,144"}},{"content":"<strong>Total complexity:</strong> <code>O(V + E)</code>","children":[],"payload":{"tag":"li","lines":"144,146"}}],"payload":{"tag":"h3","lines":"141,142"}},{"content":"<strong>For General Graphs (With Cycles):</strong>","children":[{"content":"Cycles create circular dependencies&#x2014;memoization alone is not sufficient.","children":[],"payload":{"tag":"li","lines":"147,148"}},{"content":"\n<h4 data-lines=\"149,150\"><strong>Solution: &quot;Layered&quot; Graph (Limited Number of Edges)</strong></h4>","children":[{"content":"\n<p data-lines=\"150,151\">Define: <code>&#x3b4;&#x2096;(s, v)</code> = shortest path from <code>s</code> to <code>v</code> using &#x2264; <code>k</code> edges.</p>","children":[],"payload":{"tag":"li","lines":"150,151"}},{"content":"\n<p data-lines=\"151,152\"><strong>Base cases:</strong></p>","children":[{"content":"<code>&#x3b4;&#x2080;(s, s) = 0</code> (0 edges from <code>s</code> to itself)","children":[],"payload":{"tag":"li","lines":"152,153"}},{"content":"<code>&#x3b4;&#x2080;(s, v &#x2260; s) = &#x221e;</code>","children":[],"payload":{"tag":"li","lines":"153,154"}}],"payload":{"tag":"li","lines":"151,154"}},{"content":"\n<p data-lines=\"154,155\"><strong>Recurrence:</strong></p>\n<pre data-lines=\"155,161\"><code data-lines=\"155,161\">&#x3b4;&#x2096;(s, v) <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">min</span>(\n    &#x3b4;&#x2096;&#x208b;&#x2081;(s, v),   <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">using</span> an edge ending <span class=\"hljs-keyword\">at</span> v <span class=\"hljs-keyword\">in</span> this layer\n    min <span class=\"hljs-keyword\">over</span> u: &#x3b4;&#x2096;&#x208b;&#x2081;(s, u) <span class=\"hljs-operator\">+</span> w(u, v)\n)\n</code></pre>","children":[],"payload":{"tag":"li","lines":"154,161"}},{"content":"\n<p data-lines=\"161,162\">Now the dependency graph is <strong>acyclic</strong> in parameter <code>k</code>.</p>","children":[],"payload":{"tag":"li","lines":"161,163"}},{"content":"\n<p data-lines=\"163,164\"><strong>Total subproblems:</strong> <code>V</code> vertices &#xd7; <code>V</code> layers = <code>O(V^2)</code></p>","children":[],"payload":{"tag":"li","lines":"163,164"}},{"content":"\n<p data-lines=\"164,165\"><strong>Time per subproblem:</strong> Proportional to indegree of <code>v</code>.</p>","children":[],"payload":{"tag":"li","lines":"164,165"}},{"content":"\n<p data-lines=\"165,166\"><strong>Total time:</strong> <code>O(V x E)</code> (same as Bellman-Ford algorithm).</p>","children":[],"payload":{"tag":"li","lines":"165,167"}}],"payload":{"tag":"li","lines":"148,167"}}],"payload":{"tag":"h3","lines":"146,147"}}],"payload":{"tag":"h2","lines":"139,140"}},{"content":"<strong>Connection to Bellman-Ford</strong>","children":[{"content":"<strong>Bellman-Ford</strong> can be viewed as <strong>DP</strong> over layers, updating the shortest path with increasing edge counts:","children":[{"content":"<strong>Iterative relaxation:</strong> After <code>k</code> rounds, all paths with &#x2264; <code>k</code> edges are considered.","children":[],"payload":{"tag":"li","lines":"170,171"}}],"payload":{"tag":"li","lines":"169,171"}},{"content":"<strong>Design Principle:</strong> Make subproblem dependencies <strong>acyclic</strong> (e.g., by adding &#x201c;layer&#x201d; parameter) so memoization works.","children":[],"payload":{"tag":"li","lines":"171,173"}}],"payload":{"tag":"h2","lines":"167,168"}},{"content":"<strong>Key Takeaways</strong>","children":[{"content":"<strong>Dynamic Programming</strong>:","children":[{"content":"Breaks problems into subproblems.","children":[],"payload":{"tag":"li","lines":"176,177"}},{"content":"Stores and reuses their solutions.","children":[],"payload":{"tag":"li","lines":"177,178"}},{"content":"Applies best to <strong>optimization</strong> and when subproblems overlap.","children":[],"payload":{"tag":"li","lines":"178,179"}}],"payload":{"tag":"li","lines":"175,179"}},{"content":"<strong>Memoization</strong> (top-down) and <strong>Tabulation</strong> (bottom-up) are dual techniques, often with identical runtime but tradeoffs in clarity and space.","children":[],"payload":{"tag":"li","lines":"179,180"}},{"content":"For <strong>DAGs</strong>, shortest paths via DP in <code>O(V + E)</code>.","children":[],"payload":{"tag":"li","lines":"180,181"}},{"content":"For <strong>general graphs</strong>, must add &quot;layering&quot; (limit edge count in paths) to avoid cycles; results in <code>O(V x E)</code>, equivalent to <strong>Bellman-Ford</strong>.","children":[],"payload":{"tag":"li","lines":"181,182"}},{"content":"<strong>DP Framework</strong> applies to many creative problem domains, not just paths and sequences.","children":[],"payload":{"tag":"li","lines":"182,183"}}],"payload":{"tag":"h2","lines":"173,174"}}],"payload":{"tag":"h1","lines":"0,1"}},null)</script>
</body>
</html>
